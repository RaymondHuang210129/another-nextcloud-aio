#!/usr/bin/env bash
# Wrapper to normalize go-vod ffmpeg invocations for zero-copy CUDA/NVENC/NVDEC + robust HLS,
# and to auto-apply GPU rotation (transpose_cuda) based on camera/display-matrix metadata.

set -euo pipefail

REAL=/usr/local/bin/ffmpeg.real
args=( "$@" )

# -------- helpers --------
index_of_output() {
  for ((i=0;i<${#args[@]};i++)); do
    [[ "${args[i]}" == "-" ]] && { echo "$i"; return 0; }
  done
  echo "${#args[@]}"
}
insert_before_output() {
  local -n arr=$1; shift
  local out_idx; out_idx=$(index_of_output)
  local head=( "${arr[@]:0:out_idx}" )
  local tail=( "${arr[@]:out_idx}" )
  arr=( "${head[@]}" "$@" "${tail[@]}" )
}
fix_vf() {
  local vf="$1"
  # strip bogus CPU→GPU bits
  vf="${vf//format=nv12|cuda,hwupload,/}"
  vf="${vf//format=nv12|cuda,/}"
  vf="${vf//,hwupload,/,}"
  vf="${vf//,hwupload/}"
  # ensure scale_cuda outputs GPU-friendly format
  if [[ "$vf" == *"scale_cuda="* ]] && ! [[ "$vf" =~ scale_cuda=.*format= ]]; then
    vf="${vf/scale_cuda=/scale_cuda=format=nv12:}"
  fi
  printf '%s' "$vf"
}
# splice a filter BEFORE the first scale_cuda in an existing -vf string
inject_before_scale_cuda() {
  local vf="$1" add="$2"
  if [[ "$vf" == *"scale_cuda="* ]]; then
    echo "${vf/scale_cuda=/"$add",scale_cuda=}"
  else
    echo "$add,${vf}"
  fi
}
# find the first input path (token following the first -i)
get_input_path() {
  local seen=false
  for ((k=0;k<${#args[@]};k++)); do
    if $seen; then echo "${args[k]}"; return 0; fi
    [[ "${args[k]}" == "-i" ]] && seen=true
  done
  return 1
}
# -------------------------

# 0) Make HLS segment dir if present
for ((i=0;i<${#args[@]}-1;i++)); do
  if [[ "${args[i]}" == "-hls_segment_filename" ]]; then
    mkdir -p -- "$(dirname -- "${args[i+1]}")" || true
  fi
done

# 1) Ensure zero-copy decode: prepend input options
has_outfmt=false
for ((i=0;i<${#args[@]}-1;i++)); do
  [[ "${args[i]}" == "-hwaccel_output_format" && "${args[i+1]}" == "cuda" ]] && { has_outfmt=true; break; }
done
$has_outfmt || args=( -hwaccel cuda -hwaccel_output_format cuda "${args[@]}" )

# 2) Clean the filter graph(s) first (so we inject into a normalized vf)
for ((i=0;i<${#args[@]};i++)); do
  if [[ "${args[i]}" == "-vf" || "${args[i]}" == "-filter:v" ]]; then
    (( i+1 < ${#args[@]} )) && args[i+1]="$(fix_vf "${args[i+1]}")"
  fi
done

# 2.5) Detect rotation and inject transpose_cuda BEFORE scale_cuda (GPU rotate)
INPUT_PATH="$(get_input_path || true)"
ROT_RAW=""
if [[ -n "$INPUT_PATH" && -r "$INPUT_PATH" ]]; then
  # Your requested probe: side_data=rotation, take the first line
  ROT_RAW="$(ffprobe -loglevel error -select_streams v:0 \
             -show_entries stream_side_data=rotation \
             -of default=nw=1:nk=1 -- "$INPUT_PATH" 2>/dev/null | head -n1 || true)"
  # Fallback to stream tag 'rotate' if side-data missing
  if [[ -z "$ROT_RAW" ]]; then
    ROT_RAW="$(ffprobe -loglevel error -select_streams v:0 \
               -show_entries stream_tags=rotate \
               -of default=nw=1:nk=1 -- "$INPUT_PATH" 2>/dev/null | head -n1 || true)"
  fi
fi

# Normalize to 0/90/180/270
NORM=""
ROT="${ROT_RAW//[!0-9\-]/}"   # keep only optional '-' and digits
case "$ROT" in
  90|-270)   NORM="-90" ;;
  -90|270)   NORM="90" ;;
  180|-180)  NORM="180" ;;
  0|""|+0|-0) NORM="0" ;;
  *)         NORM="0" ;;  # unknown → ignore
esac

echo "ROTATION: $NORM" >&2

if [[ "$NORM" != "0" ]]; then
  # build transpose_cuda sequence
  case "$NORM" in
    90)   ROTF="transpose_cuda=clock" ;;     # 90° clockwise
    -90)  ROTF="transpose_cuda=cclock" ;;    # 90° counter-clockwise
    180)  ROTF="transpose_cuda=clock,transpose_cuda=clock" ;;  # two steps
  esac
  # inject into each -vf/-filter:v BEFORE scale_cuda
  for ((i=0;i<${#args[@]};i++)); do
    if [[ "${args[i]}" == "-vf" || "${args[i]}" == "-filter:v" ]]; then
      if (( i+1 < ${#args[@]} )); then
        args[i+1]="$(inject_before_scale_cuda "${args[i+1]}" "$ROTF")"
      fi
    fi
  done
fi

# 3) Remove timestamp troublemakers for HLS
filtered=(); skip=false
for ((i=0;i<${#args[@]};i++)); do
  if $skip; then skip=false; continue; fi
  [[ "${args[i]}" == "-copyts" ]] && continue
  if [[ "${args[i]}" == "-fflags" && "${args[i+1]:-}" == "+genpts" ]]; then
    skip=true; continue
  fi
  # strip any earlier -avoid_negative_ts (we'll add our preferred one later)
  if [[ "${args[i]}" == "-avoid_negative_ts" ]]; then
    skip=true; continue
  fi
  filtered+=( "${args[i]}" )
done
args=( "${filtered[@]}" )

# 4) Force CFR 30 fps (output option)
has_rv=false
for ((i=0;i<${#args[@]};i++)); do
  [[ "${args[i]}" == "-r" || "${args[i]}" == "-r:v" ]] && { has_rv=true; break; }
done
$has_rv || insert_before_output args -r:v 30

# 5) HLS: prefer independent segments; drop split_by_time; add force_key_frames
# read -hls_time (default 3)
hls_time=3
for ((i=0;i<${#args[@]}-1;i++)); do
  if [[ "${args[i]}" == "-hls_time" ]]; then
    hls_time="${args[i+1]%.*}"
  fi
done

# sanitize -hls_flags
have_hls_flags=false
for ((i=0;i<${#args[@]}-1;i++)); do
  if [[ "${args[i]}" == "-hls_flags" ]]; then
    have_hls_flags=true
    args[i+1]="$(echo "${args[i+1]}" | sed -E 's/\+?split_by_time//g; s/\+\+/\+/g; s/^\+//; s/\+$//')"
    [[ "${args[i+1]}" == *"independent_segments"* ]] || args[i+1]="${args[i+1]}${args[i+1]:+ +}independent_segments"
  fi
done
$have_hls_flags || insert_before_output args -hls_flags independent_segments

# GOP alignment (N = 30 * hls_time)
g=$(( 30 * hls_time ))
need_g=true; need_k=true; need_sc=true
for ((i=0;i<${#args[@]};i++)); do
  [[ "${args[i]}" == "-g" ]] && need_g=false
  [[ "${args[i]}" == "-keyint_min" ]] && need_k=false
  [[ "${args[i]}" == "-sc_threshold" ]] && need_sc=false
endone=false
done
$need_g && insert_before_output args -g "$g"
$need_k && insert_before_output args -keyint_min "$g"
$need_sc && insert_before_output args -sc_threshold 0

# Force key frames at boundaries if not present
have_fkf=false
for ((i=0;i<${#args[@]};i++)); do
  [[ "${args[i]}" == "-force_key_frames" ]] && { have_fkf=true; break; }
done
$have_fkf || insert_before_output args -force_key_frames "expr:gte(t,n_forced*${hls_time})"

# 6) Low-latency: if tune=ll, set rc-lookahead=0
has_tune_ll=false; rc_idx=-1
for ((i=0;i<${#args[@]}-1;i++)); do
  [[ "${args[i]}" == "-tune" && "${args[i+1]}" == "ll" ]] && has_tune_ll=true
  [[ "${args[i]}" == "-rc-lookahead" ]] && rc_idx=$((i+1))
done
if $has_tune_ll; then
  if (( rc_idx >= 0 )); then args[$rc_idx]=0
  else insert_before_output args -rc-lookahead 0
  fi
fi

# 7) Timestamp hygiene for TS
insert_before_output args -muxpreload 0 -muxdelay 0 -avoid_negative_ts make_zero

# 8) Optional: switch to fMP4 segments if env asks
if [[ "${HLS_FMP4:-0}" == "1" ]]; then
  insert_before_output args -hls_segment_type fmp4
  insert_before_output args -movflags +frag_keyframe+empty_moov
fi

# Debug: show final args
echo "FINAL ARGS: ${args[*]}" >&2

exec "$REAL" "${args[@]}"
