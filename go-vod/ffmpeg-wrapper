#!/usr/bin/env bash
# Wrapper to normalize go-vod ffmpeg invocations for zero-copy CUDA/NVENC/NVDEC + robust HLS.

set -euo pipefail

REAL=/usr/local/bin/ffmpeg.real
args=( "$@" )

# -------- helpers --------
index_of_output() {
  for ((i=0;i<${#args[@]};i++)); do
    [[ "${args[i]}" == "-" ]] && { echo "$i"; return 0; }
  done
  echo "${#args[@]}"
}
insert_before_output() {
  local -n arr=$1; shift
  local out_idx; out_idx=$(index_of_output)
  local head=( "${arr[@]:0:out_idx}" )
  local tail=( "${arr[@]:out_idx}" )
  arr=( "${head[@]}" "$@" "${tail[@]}" )
}
fix_vf() {
  local vf="$1"
  # strip bogus CPUâ†’GPU bits
  vf="${vf//format=nv12|cuda,hwupload,/}"
  vf="${vf//format=nv12|cuda,/}"
  vf="${vf//,hwupload,/,}"
  vf="${vf//,hwupload/}"
  # ensure scale_cuda outputs GPU-friendly format
  if [[ "$vf" == *"scale_cuda="* ]] && ! [[ "$vf" =~ scale_cuda=.*format= ]]; then
    vf="${vf/scale_cuda=/scale_cuda=format=nv12:}"
  fi
  printf '%s' "$vf"
}
# -------------------------

# 0) Make HLS segment dir if present
for ((i=0;i<${#args[@]}-1;i++)); do
  if [[ "${args[i]}" == "-hls_segment_filename" ]]; then
    mkdir -p -- "$(dirname -- "${args[i+1]}")" || true
  fi
done

# 1) Add -noautorotate to avoid double rotation
# have_noauto=false
# for a in "${args[@]}"; do [[ "$a" == "-noautorotate" ]] && have_noauto=true; done
# $have_noauto || args=( -noautorotate "${args[@]}" )

# 2) Ensure zero-copy decode: prepend input options
has_outfmt=false
for ((i=0;i<${#args[@]}-1;i++)); do
  [[ "${args[i]}" == "-hwaccel_output_format" && "${args[i+1]}" == "cuda" ]] && { has_outfmt=true; break; }
done
$has_outfmt || args=( -hwaccel cuda -hwaccel_output_format cuda "${args[@]}" )

# 3) Clean the filter graph(s)
for ((i=0;i<${#args[@]};i++)); do
  if [[ "${args[i]}" == "-vf" || "${args[i]}" == "-filter:v" ]]; then
    (( i+1 < ${#args[@]} )) && args[i+1]="$(fix_vf "${args[i+1]}")"
  fi
done

# 4) Remove timestamp troublemakers for HLS
filtered=(); skip=false
for ((i=0;i<${#args[@]};i++)); do
  if $skip; then skip=false; continue; fi
  [[ "${args[i]}" == "-copyts" ]] && continue
  if [[ "${args[i]}" == "-fflags" && "${args[i+1]:-}" == "+genpts" ]]; then
    skip=true; continue
  fi
  filtered+=( "${args[i]}" )
done
args=( "${filtered[@]}" )

# 5) Force CFR 30 fps (output option)
has_rv=false
for ((i=0;i<${#args[@]};i++)); do
  [[ "${args[i]}" == "-r" || "${args[i]}" == "-r:v" ]] && { has_rv=true; break; }
done
$has_rv || insert_before_output args -r:v 30

# 6) HLS: prefer independent segments; drop split_by_time; add force_key_frames
# read -hls_time (default 3)
hls_time=3
for ((i=0;i<${#args[@]}-1;i++)); do
  if [[ "${args[i]}" == "-hls_time" ]]; then
    hls_time="${args[i+1]%.*}"
  fi
done

# sanitize -hls_flags
have_hls_flags=false
for ((i=0;i<${#args[@]}-1;i++)); do
  if [[ "${args[i]}" == "-hls_flags" ]]; then
    have_hls_flags=true
    # remove split_by_time; normalize separators
    args[i+1]="$(echo "${args[i+1]}" | sed -E 's/\+?split_by_time//g; s/\+\+/\+/g; s/^\+//; s/\+$//')"
    [[ "${args[i+1]}" == *"independent_segments"* ]] || args[i+1]="${args[i+1]}${args[i+1]:+ +}independent_segments"
  fi
done
$have_hls_flags || insert_before_output args -hls_flags independent_segments

# GOP alignment
g=$(( 30 * hls_time ))
need_g=true; need_k=true; need_sc=true
for ((i=0;i<${#args[@]};i++)); do
  [[ "${args[i]}" == "-g" ]] && need_g=false
  [[ "${args[i]}" == "-keyint_min" ]] && need_k=false
  [[ "${args[i]}" == "-sc_threshold" ]] && need_sc=false
endone=false
done  # (the 'endone' line is just a guard to avoid accidental 'done' removal by editors)
$need_g && insert_before_output args -g "$g"
$need_k && insert_before_output args -keyint_min "$g"
$need_sc && insert_before_output args -sc_threshold 0

# Force key frames at boundaries if not present
have_fkf=false
for ((i=0;i<${#args[@]};i++)); do
  [[ "${args[i]}" == "-force_key_frames" ]] && { have_fkf=true; break; }
done
$have_fkf || insert_before_output args -force_key_frames "expr:gte(t,n_forced*${hls_time})"

# 7) Low-latency: if tune=ll, set rc-lookahead=0
has_tune_ll=false; rc_idx=-1
for ((i=0;i<${#args[@]}-1;i++)); do
  [[ "${args[i]}" == "-tune" && "${args[i+1]}" == "ll" ]] && has_tune_ll=true
  [[ "${args[i]}" == "-rc-lookahead" ]] && rc_idx=$((i+1))
done
if $has_tune_ll; then
  if (( rc_idx >= 0 )); then args[$rc_idx]=0
  else insert_before_output args -rc-lookahead 0
  fi
fi

# 8) Timestamp hygiene for TS
insert_before_output args -muxpreload 0 -muxdelay 0 -avoid_negative_ts make_zero

# 9) Optional: switch to fMP4 segments if env asks (often more MSE-friendly)
if [[ "${HLS_FMP4:-0}" == "1" ]]; then
  # replace/append HLS options for fMP4
  insert_before_output args -hls_segment_type fmp4
  # optional init segment name if your player expects it:
  # insert_before_output args -hls_fmp4_init_filename init.mp4
  # and for MP4 fragging:
  insert_before_output args -movflags +frag_keyframe+empty_moov
fi

# Debug: show final args
echo "FINAL ARGS: ${args[*]}" >&2

exec "$REAL" "${args[@]}"
